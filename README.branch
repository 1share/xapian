brass-btree branch
==================

Status:

  * All tests pass.

  * Some things not fully (or at all) implemented.

TODO:
-----

Missing features:

  * tracking free blocks.

  * tracking free slabs.

  * xapian-check checking Btree structure (currently only checks data inside
    tables).

  * xapian-check of an individual table

  * xapian-inspect - make it handle flint/chert and brass in one binary.

  * replication

Testing:

  * look at code coverage from the testsuite, and add tests to exercise as
    much of the code as possible

  * make sure we have test coverage for cancel() when the table became empty in
    the cancelled changes.

Potential size improvements:

  * if the blocksize is < 64K we have one or more unused bits in each item
    pointer - we can use these in leaf blocks to store the compressed and/or
    slab flags, instead of having to encode these in the item.

  * if the blocksize is < 64K we have one or more unused bits in each item
    pointer - we can use these in branch blocks to store the length of the
    block pointer, so we can save a byte or two on this in many cases (at the
    expense of updating it potentially overflowing the block).  If we store
    items in branch blocks that would clash with this idea.

  * use spare bits in the "key length" byte for either storing some bits of
    the slab pointer, or for allowing longer in-tree tags.

  * prefix-compress keys (to make large tables smaller)

  * look at making the dividing keys in branch blocks into actual entries?

  * B*-tree mode for block splitting?

Potential speed improvements:

  * cursor snooping currently O(# depth of tree)...

  * compare speed with chert (e.g. profile running the testsuite) and try to
    make sure we're at least as fast everywhere.

Miscellaneous:

  * is it cleaner to explicitly store the null key (as we currently do) or
    not to?

  * store database stats in the version file rather than a special entry in the
    postlist table?  Putting it in the table churns the left-most leaf block
    of the table on every commit.

  * slabs could go in the .brass file - we could pre-allocate a chunk of blocks
    for this, and the block freespace tracking would just ignore that
    automatically.  One slight downside is the slab pointers will tend be a bit
    longer.  Upside is that there are fewer files to open, fsync(), etc.  What
    about replication?
