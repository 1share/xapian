%rename(increment) *::next();
%rename(increment_weight) *::next(Xapian::weight min_wt);

%rename(query_new1) Xapian::Query::Query(const std::string & tname);
%rename(query_new1weight) Xapian::Query::Query(const std::string &tname, Xapian::termcount wqf, Xapian::termpos pos);
%rename(query_new3scale) Xapian::Query::Query(Query::op op, Xapian::Query q, double parameter);
%rename(query_new3range) Xapian::Query::Query(Query::op op, Xapian::valueno valno, const std::string &value);
%rename(query_new4range) Xapian::Query::Query(Query::op op, Xapian::valueno valno, const std::string &begin, const std::string &end);
%ignore Xapian::Query::Query;

%rename(set_query1) Xapian::Enquire::set_query(const Query & query);
%rename(set_query2) Xapian::Enquire::set_query(const Query & query, termcount qlen);

%constant int OP_AND = Xapian::Query::OP_AND;
%constant int OP_OR = Xapian::Query::OP_OR;
%constant int OP_AND_NOT = Xapian::Query::OP_AND_NOT;
%constant int OP_XOR = Xapian::Query::OP_XOR;
%constant int OP_AND_MAYBE = Xapian::Query::OP_AND_MAYBE;
%constant int OP_FILTER = Xapian::Query::OP_FILTER;
%constant int OP_NEAR = Xapian::Query::OP_NEAR;
%constant int OP_PHRASE = Xapian::Query::OP_PHRASE;
%constant int OP_VALUE_RANGE = Xapian::Query::OP_VALUE_RANGE;
%constant int OP_SCALE_WEIGHT = Xapian::Query::OP_SCALE_WEIGHT;
%constant int OP_ELITE_SET = Xapian::Query::OP_ELITE_SET;
%constant int OP_VALUE_RANGE = Xapian::Query::OP_VALUE_RANGE;
%constant int OP_VALUE_GE = Xapian::Query::OP_VALUE_GE;
%constant int OP_VALUE_LE = Xapian::Query::OP_VALUE_LE;

%constant int FLAG_BOOLEAN = Xapian::QueryParser::FLAG_BOOLEAN;
%constant int FLAG_PHRASE = Xapian::QueryParser::FLAG_PHRASE;
%constant int FLAG_LOVEHATE = Xapian::QueryParser::FLAG_LOVEHATE;
%constant int FLAG_BOOLEAN_ANY_CASE = Xapian::QueryParser::FLAG_BOOLEAN_ANY_CASE;
%constant int FLAG_WILDCARD = Xapian::QueryParser::FLAG_WILDCARD;
%constant int FLAG_PURE_NOT = Xapian::QueryParser::FLAG_PURE_NOT;
%constant int FLAG_PARTIAL = Xapian::QueryParser::FLAG_PARTIAL;
%constant int FLAG_SPELLING_CORRECTION = Xapian::QueryParser::FLAG_SPELLING_CORRECTION;
%constant int FLAG_SYNONYM = Xapian::QueryParser::FLAG_SYNONYM;
%constant int FLAG_AUTO_SYNONYMS = Xapian::QueryParser::FLAG_AUTO_SYNONYMS;
%constant int FLAG_AUTO_MULTIWORD_SYNONYMS = Xapian::QueryParser::FLAG_AUTO_MULTIWORD_SYNONYMS;
%constant int FLAG_DEFAULT = Xapian::QueryParser::FLAG_DEFAULT;

%constant int STEM_NONE = Xapian::QueryParser::STEM_NONE;
%constant int STEM_SOME = Xapian::QueryParser::STEM_SOME;
%constant int STEM_ALL = Xapian::QueryParser::STEM_ALL;

%constant int FLAG_SPELLING = Xapian::TermGenerator::FLAG_SPELLING;

%typemap(in) SV ** {
	AV *tempav;
	I32 len;
	int i;
	SV  **tv;
	if (!SvROK($input))
	    croak("Argument $argnum is not a reference.");
        if (SvTYPE(SvRV($input)) != SVt_PVAV)
	    croak("Argument $argnum is not an array.");
        tempav = (AV*)SvRV($input);
	len = av_len(tempav);
	$1 = (SV **) malloc((len+2)*sizeof(SV *));
	for (i = 0; i <= len; i++) {
	    tv = av_fetch(tempav, i, 0);
	    $1[i] = *tv;
        }
	$1[i] = NULL;
};

%typemap(freearg) SV ** {
	free($1);
}

%inline %{
Xapian::Query * newN(int op_, int items, SV ** q) {
	Xapian::Query::op op = (Xapian::Query::op)op_;
	Xapian::Query * ret;

	try {
	    vector<Xapian::Query> queries;
	    queries.reserve(items);

	    for( int i = 0; i < items; i++ ) {
		SV *sv = (SV *)q[i];
		if (sv_isa(sv, "Search::Xapian::Query")) {
		    Xapian::Query *query = (Xapian::Query*) SvIV((SV*) SvRV(sv));
		    queries.push_back(*query);
		} else if ( SvOK(sv) ) {
		    STRLEN len;
		    const char * ptr = SvPV(sv, len);
		    queries.push_back(Xapian::Query(string(ptr, len)));
		} else {
		    croak( "USAGE: Search::Xapian::Query->new(OP, @TERMS_OR_QUERY_OBJECTS)" );
		}
	    }
            ret = new Xapian::Query(op, queries.begin(), queries.end());
        } catch (const Xapian::Error &error) {
            croak( "Exception: %s", error.get_msg().c_str() );
        }
	return ret;
}
%}

%rename(get_mset1) Xapian::Enquire::get_mset;

%extend Xapian::Stem {
std::string stem_word(std::string word) {
	    return (*self)(word);
}
}

%extend Xapian::ValueIterator {
bool equal(Xapian::ValueIterator * that) {
     return ((*self) == (*that));
}

bool nequal(Xapian::ValueIterator * that) {
     return ((*self) != (*that));
}
}

%ignore Xapian::WritableDatabase::replace_document(Xapian::docid, Xapian::Document * document);
%ignore Xapian::WritableDatabase::delete_document(Xapian::docid did);

%feature("shadow") Xapian::WritableDatabase::WritableDatabase
%{
sub new {
  my $pkg = shift;
  my $self;
  if( scalar(@_) == 0 ) {
    $self = Search::Xapianc::new3_WritableDatabase(@_);
  } else {
    $self = Search::Xapianc::new_WritableDatabase(@_);
  }
  bless $self, $pkg if defined($self);
}
%}

%extend Xapian::WritableDatabase {
void replace_document(Xapian::docid, Xapian::Document * document) {
        try {
	    self->replace_document(did, *document);
        }
        catch (const Xapian::Error &error) {
            croak( "Exception: %s", error.get_msg().c_str() );
        }
}

void replace_document_by_term(std::string unique_term, Xapian::Document * document) {
        try {
	    self->replace_document(unique_term, *document);
        }
        catch (const Xapian::Error &error) {
            croak( "Exception: %s", error.get_msg().c_str() );
        }
}

void delete_document(Xapian::docid did) {
        try {
	    self->delete_document(did);
        }
        catch (const Xapian::Error &error) {
            croak( "Exception: %s", error.get_msg().c_str() );
        }
}

void delete_document_by_term(std::string unique_term) {
        try {
	    self->delete_document(unique_term);
        }
        catch (const Xapian::Error &error) {
            croak( "Exception: %s", error.get_msg().c_str() );
        }
}
}

%inline %{
Xapian::WritableDatabase * new3_WritableDatabase() {
        try {
	    return new Xapian::WritableDatabase(Xapian::InMemory::open());
        }
        catch (const Xapian::Error &error) {
            croak( "Exception: %s", error.get_msg().c_str() );
        }
}
%}

%extend Xapian::TermIterator {
bool equal(Xapian::TermIterator * that) {
     return ((*self) == (*that));
}

bool nequal(Xapian::TermIterator * that) {
     return ((*self) != (*that));
}
}

%rename(get_termname) Xapian::TermIterator::get_term;

%feature("shadow") Xapian::SimpleStopper::SimpleStopper
%{
sub new {
    my $class = shift;
    my $stopper = Search::Xapianc::new_SimpleStopper();

    bless $stopper, $class;
    foreach (@_) {
	$stopper->add($_);
    }

    return $stopper;
}
%}

%extend Xapian::SimpleStopper {
bool stop_word(std::string term) {
     return (*self)(term);
}
}

%extend Xapian::PositionIterator {
bool equal1(Xapian::PositionIterator * that) {
     return ((*self) == (*that));
}

bool nequal1(Xapian::PositionIterator * that) {
     return ((*self) != (*that));
}
}

%feature("shadow") Xapian::QueryParser::QueryParser
%{
sub new {
  my $class = shift;
  my $qp = Search::Xapianc::new_QueryParser();

  bless $qp, $class;
  $qp->set_database(@_) if scalar(@_) == 1;

  return $qp;
}
%}

%rename(set_stopper0) Xapian::QueryParser::set_stopper();
%rename(set_stopper1) Xapian::QueryParser::set_stopper(const Stopper * stopper);
%rename(add_valuerangeprocessor1) Xapian::QueryParser::add_valuerangeprocessor(Xapian::ValueRangeProcessor * vrproc);

%rename(set_stopper0) Xapian::TermGenerator::set_stopper();
%rename(set_stopper1) Xapian::TermGenerator::set_stopper(const Xapian::Stopper * stopper);

%rename(set_sort_by_key1) Xapian::Enquire::set_sort_by_key(Xapian::MultiValueSorter * sorter, bool ascending);
%rename(set_sort_by_key_then_relevance1) Xapian::Enquire::set_sort_by_key_then_relevance(Xapian::MultiValueSorter * sorter, bool ascending);
%rename(set_sort_by_relevance_then_key1) Xapian::Enquire::set_sort_by_relevance_then_key(Xapian::MultiValueSorter * sorter, bool ascending);

%perlcode %{
package Search::Xapian;	

our $VERSION = "@PERL_XAPIAN_VERSION@";

# Items to export into caller's namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration	use Search::Xapian ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = (
                    'ops' => [ qw(
                                  OP_AND
                                  OP_OR
                                  OP_AND_NOT
                                  OP_XOR
                                  OP_AND_MAYBE
                                  OP_FILTER
                                  OP_NEAR
                                  OP_PHRASE
				  OP_VALUE_RANGE
				  OP_SCALE_WEIGHT
                                  OP_ELITE_SET
				  OP_VALUE_GE
				  OP_VALUE_LE
                                 ) ],
                    'db' => [ qw(
                                 DB_OPEN
                                 DB_CREATE
                                 DB_CREATE_OR_OPEN
                                 DB_CREATE_OR_OVERWRITE
                                 ) ],
                    'enq_order' => [ qw(
				 ENQ_DESCENDING
				 ENQ_ASCENDING
				 ENQ_DONT_CARE
				   ) ],
                    'qpflags' => [ qw(
				 FLAG_BOOLEAN
				 FLAG_PHRASE
				 FLAG_LOVEHATE
				 FLAG_BOOLEAN_ANY_CASE
				 FLAG_WILDCARD
				 FLAG_PURE_NOT
				 FLAG_PARTIAL
				 FLAG_SPELLING_CORRECTION
				 FLAG_SYNONYM
				 FLAG_AUTO_SYNONYMS
				 FLAG_AUTO_MULTIWORD_SYNONYMS
				 FLAG_DEFAULT
                                 ) ],
                    'qpstem' => [ qw(
				 STEM_NONE
				 STEM_SOME
				 STEM_ALL
                                 ) ]
                   );
$EXPORT_TAGS{standard} = [ @{ $EXPORT_TAGS{'ops'} },
			   @{ $EXPORT_TAGS{'db'} },
			   @{ $EXPORT_TAGS{'qpflags'} },
			   @{ $EXPORT_TAGS{'qpstem'} } ];
$EXPORT_TAGS{all} = [ @{ $EXPORT_TAGS{'standard'} }, @{ $EXPORT_TAGS{'enq_order'} } ];


our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

# Preloaded methods go here.

our @OP_NAMES;
foreach (@{ $EXPORT_TAGS{'ops'} }) {
  $OP_NAMES[eval $_] = $_;
}

our @DB_NAMES;
foreach (@{ $EXPORT_TAGS{'db'} }) {
  $DB_NAMES[eval $_] = $_;
}

our @FLAG_NAMES;
foreach (@{ $EXPORT_TAGS{'qpflags'} }) {
  $FLAG_NAMES[eval $_] = $_;
}

our @STEM_NAMES;
foreach (@{ $EXPORT_TAGS{'qpstem'} }) {
  $STEM_NAMES[eval $_] = $_;
}

package Search::Xapian::Database;
sub enquire {
  my $self = shift;
  my $enquire = Search::Xapian::Enquire->new( $self );
  if( @_ ) {
    $enquire->set_query( @_ );
  }
  return $enquire;
}

package Search::Xapian::Query;
sub new {
  my $class = $_[0];
  my $query;

  if( @_ == 2 ) {
    $query = new_query_new1(@_);
  } else {
    my $op = $_[1];
    if( $op !~ /^\d+$/ ) {
	Carp::croak( "USAGE: $class->new('term') or $class->new(OP, <args>)" );
    }
    if( $op == 8 ) { # FIXME: 8 is OP_VALUE_RANGE; eliminate hardcoded literal
      if( @_ != 5 ) {
	Carp::croak( "USAGE: $class->new(OP_VALUE_RANGE, VALNO, START, END)" );
      }
      $query = new_query_new4range( @_ );
    } elsif( $op == 9 ) { # FIXME: OP_SCALE_WEIGHT
      if( @_ != 4 ) {
        Carp::croak( "USAGE: $class->new(OP_SCALE_WEIGHT, QUERY, FACTOR)" );
      }
      $query = new_query_new3scale( @_ );
    } elsif( $op == 11 || $op == 12 ) { # FIXME: OP_VALUE_GE, OP_VALUE_LE; eliminate hardcoded literals
      if( @_ != 4 ) {
        Carp::croak( "USAGE: $class->new(OP_VALUE_[GL]E, VALNO, LIMIT)" );
      }
      $query = new_query_new3range( @_ );
    } else {
      shift @_;
      shift @_;
      my $items = scalar(@_);
      my @arr;
      foreach my $item (@_) {
	  if ( ref( $item ) eq 'Search::Xapian::Query' ) {
	      push(@arr, ref($item));
	  } else {
	      push(@arr, $item);
	  }
      }

     $query = Search::Xapian::newN( $op, $items, \@arr );
    }
  }
  return $query;
}

package Search::Xapian::Enquire;
sub set_query {
  my $self = shift;
  my $query = shift;
  if( ref( $query ) ne 'Search::Xapian::Query' ) {
    $query = Search::Xapian::Query->new( $query, @_ );
    $self->set_query1( $query );
    return;
  }
  my $nargs = scalar(@_);
  if( $nargs > 1) {
    Carp::carp( "USAGE: \$enquire->set_query(\$query) or \$enquire->set_query(\$query, \$length)" );
    exit;
  }
  if( $nargs == 0 ) {
    $self->set_query1( $query );
  } else {
    $self->set_query2( $query, shift );
  }
}

sub get_mset {
  my $self = shift;
  my $nargs = scalar(@_);
  if( $nargs == 3 ) {
    my $type = ref( $_[2] );
    if ( $type eq 'Search::Xapian::RSet' ) {
      # get_mset(first, max, rset)
      splice @_, 2, 0, (0); # insert checkatleast
    }
  }
  return $self->get_mset1( @_ );
}

sub set_sort_by_key {
    my $self = $_[0];
    my $sorter = $_[1];
    $self{_sorter} = $sorter;
    set_sort_by_key1( @_ );
}

sub set_sort_by_key_then_relevance {
    my $self = $_[0];
    my $sorter = $_[1];
    $self{_sorter} = $sorter;
    set_sort_by_key_then_relevance1( @_ );
}

sub set_sort_by_relevance_then_key {
    my $self = $_[0];
    my $sorter = $_[1];
    $self{_sorter} = $sorter;
    set_sort_by_relevance_then_key1( @_ );
}

sub matches {
  my $self = shift;
  return $self->get_mset(@_)->items();
}

package Search::Xapian::ValueIterator;
use overload '++' => sub { $_[0]->increment() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

package Search::Xapian::TermIterator;
use overload '++' => sub { $_[0]->increment() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

package Search::Xapian::QueryParser;

sub set_stopper {
    my ($self, $stopper) = @_;
    $self{_stopper} = $stopper;
    set_stopper1( @_ );
}

sub add_valuerangeprocessor {
    my ($self, $vrproc) = @_;
    push @{$self{_vrproc}}, $vrproc;
    add_valuerangeprocessor1( @_ );
}

package Search::Xapian::PositionIterator;
use UNIVERSAL qw( isa );
use overload '++' => sub { $_[0]->increment() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             '""' => sub { $_[0]->get_description() },
             '0+' => sub { $_[0]->get_termpos() },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

sub equal() {
  my ($self, $other) = @_;
  if( isa($other, 'Search::Xapian::PositionIterator') ) {
    $self->equal1($other);
  } else {
    ($self+0) == ($other+0);
  }
}

sub nequal() {
  my ($self, $other) = @_;
  if( isa($other, 'Search::Xapian::PositionIterator') ) {
    $self->nequal1($other);
  } else {
    ($self+0) != ($other+0);
  }
}

package Search::Xapian::TermGenerator;
sub set_stopper {
    my ($self, $stopper) = @_;
    $self{_stopper} = $stopper;
    set_stopper1( @_ );
}

package Search::Xapian::MSetIterator;
use overload '++' => sub { $_[0]->increment() },
	     '--' => sub { $_[0]->prev() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  bless $self, $class;
  return $self;
}
%}

%extend Xapian::MSetIterator {
bool equal(Xapian::MSetIterator * that) {
     return ((*self) == (*that));
}

bool nequal(Xapian::MSetIterator * that) {
     return ((*self) != (*that));
}
}

%perlcode %{
package Search::Xapian::MSet;
use Tie::Array;
our @ISA = qw(Tie::Array);

sub items {
  my $self = shift;
  my @array;
  tie( @array, 'Search::Xapian::MSet::Tied', $self );
  return @array;
}

sub TIEARRAY {
  my $class = shift;
  my $mset = shift;
  return bless $mset, $class;
}

sub FETCHSIZE {
    my $self = shift;
    return $self->size();
}

package Search::Xapian::MSet::Tied;
our @ISA = qw(Search::Xapian::MSet);

package Search::Xapian::ESet;
sub items {
  my $self = shift;
  my @array;
  tie( @array, 'Search::Xapian::ESet', $self );
  return @array;
}

use overload '++' => sub { $_[0]->increment() },
	     '--' => sub { $_[0]->prev() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

sub TIEARRAY {
  my $class = shift;
  my $eset = shift;
  return bless $eset, $class;
}

sub FETCHSIZE {
    my $self = shift;
    return $self->size();
}

%}

%extend Xapian::MSet {
Xapian::MSetIterator FETCH(int index) {
    return ((*self)[index]);
}
}

%extend Xapian::ESet {
Xapian::ESetIterator FETCH(int index) {
    return ((*self)[index]);
}
}

%extend Xapian::ESetIterator {
std::string get_termname() {
    return self->operator*();
}

bool equal(Xapian::ESetIterator * that) {
    return ((*self) == (*that));
}

bool nequal(Xapian::ESetIterator * that) {
    return ((*self) != (*that));
}
}

%perlcode %{
package Search::Xapian::LogicError;
sub CLONE_SKIP { 1 }
package Search::Xapian::PositionIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::PostingIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::TermIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::Document;
sub CLONE_SKIP { 1 }
package Search::Xapian::PostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValuePostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueWeightPostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueMapPostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::FixedWeightPostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::MSet;
sub CLONE_SKIP { 1 }
package Search::Xapian::MSetIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::ESet;
sub CLONE_SKIP { 1 }
package Search::Xapian::ESetIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::RSet;
sub CLONE_SKIP { 1 }
package Search::Xapian::MatchDecider;
sub CLONE_SKIP { 1 }
package Search::Xapian::Enquire;
sub CLONE_SKIP { 1 }
package Search::Xapian::Weight;
sub CLONE_SKIP { 1 }
package Search::Xapian::BoolWeight;
sub CLONE_SKIP { 1 }
package Search::Xapian::BM25Weight;
sub CLONE_SKIP { 1 }
package Search::Xapian::TradWeight;
sub CLONE_SKIP { 1 }
package Search::Xapian::Database;
sub CLONE_SKIP { 1 }
package Search::Xapian::WritableDatabase;
sub CLONE_SKIP { 1 }
package Search::Xapian::Query;
sub CLONE_SKIP { 1 }
package Search::Xapian::Stopper;
sub CLONE_SKIP { 1 }
package Search::Xapian::SimpleStopper;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Search::Xapian::StringValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Search::Xapian::DateValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Search::Xapian::NumberValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Search::Xapian::QueryParser;
sub CLONE_SKIP { 1 }
package Search::Xapian::Stem;
sub CLONE_SKIP { 1 }
package Search::Xapian::TermGenerator;
sub CLONE_SKIP { 1 }
package Search::Xapian::Sorter;
sub CLONE_SKIP { 1 }
package Search::Xapian::MultiValueSorter;
sub CLONE_SKIP { 1 }
package Search::Xapian::ReplicationInfo;
sub CLONE_SKIP { 1 }
package Search::Xapian::DatabaseMaster;
sub CLONE_SKIP { 1 }
package Search::Xapian::DatabaseReplica;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueSetMatchDecider;
sub CLONE_SKIP { 1 }
package Search::Xapian::SerialisationContext;
sub CLONE_SKIP { 1 }
package Search::Xapian::MSet::Tied;
sub CLONE_SKIP { 1 }
%}

%perlcode %{
package Search::Xapian::ESetIterator;
use overload '++' => sub { $_[0]->increment() },
	     '--' => sub { $_[0]->prev() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}
%}
