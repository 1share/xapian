%rename(increment) *::next();
%rename(increment_weight) *::next(Xapian::weight min_wt);

%rename(query_new1) Xapian::Query::Query(const std::string & tname);
%rename(query_new1weight) Xapian::Query::Query(const std::string &tname, Xapian::termcount wqf, Xapian::termpos pos);
%rename(query_new3scale) Xapian::Query::Query(Query::op op, Xapian::Query q, double parameter);
%rename(query_new3range) Xapian::Query::Query(Query::op op, Xapian::valueno valno, const std::string &value);
%rename(query_new4range) Xapian::Query::Query(Query::op op, Xapian::valueno valno, const std::string &begin, const std::string &end);

%rename(set_query1) Xapian::Enquire::set_query(const Query & query);
%rename(set_query2) Xapian::Enquire::set_query(const Query & query, termcount qlen);

%constant int OP_AND = Xapian::Query::OP_AND;
%constant int OP_OR = Xapian::Query::OP_OR;
%constant int OP_AND_NOT = Xapian::Query::OP_AND_NOT;
%constant int OP_XOR = Xapian::Query::OP_XOR;
%constant int OP_AND_MAYBE = Xapian::Query::OP_AND_MAYBE;
%constant int OP_FILTER = Xapian::Query::OP_FILTER;
%constant int OP_NEAR = Xapian::Query::OP_NEAR;
%constant int OP_PHRASE = Xapian::Query::OP_PHRASE;
%constant int OP_VALUE_RANGE = Xapian::Query::OP_VALUE_RANGE;
%constant int OP_SCALE_WEIGHT = Xapian::Query::OP_SCALE_WEIGHT;
%constant int OP_ELITE_SET = Xapian::Query::OP_ELITE_SET;
%constant int OP_VALUE_RANGE = Xapian::Query::OP_VALUE_RANGE;
%constant int OP_VALUE_GE = Xapian::Query::OP_VALUE_GE;
%constant int OP_VALUE_LE = Xapian::Query::OP_VALUE_LE;

%constant int FLAG_BOOLEAN = Xapian::QueryParser::FLAG_BOOLEAN;
%constant int FLAG_PHRASE = Xapian::QueryParser::FLAG_PHRASE;
%constant int FLAG_LOVEHATE = Xapian::QueryParser::FLAG_LOVEHATE;
%constant int FLAG_BOOLEAN_ANY_CASE = Xapian::QueryParser::FLAG_BOOLEAN_ANY_CASE;
%constant int FLAG_WILDCARD = Xapian::QueryParser::FLAG_WILDCARD;
%constant int FLAG_PURE_NOT = Xapian::QueryParser::FLAG_PURE_NOT;
%constant int FLAG_PARTIAL = Xapian::QueryParser::FLAG_PARTIAL;
%constant int FLAG_SPELLING_CORRECTION = Xapian::QueryParser::FLAG_SPELLING_CORRECTION;
%constant int FLAG_SYNONYM = Xapian::QueryParser::FLAG_SYNONYM;
%constant int FLAG_AUTO_SYNONYMS = Xapian::QueryParser::FLAG_AUTO_SYNONYMS;
%constant int FLAG_AUTO_MULTIWORD_SYNONYMS = Xapian::QueryParser::FLAG_AUTO_MULTIWORD_SYNONYMS;
%constant int FLAG_DEFAULT = Xapian::QueryParser::FLAG_DEFAULT;

%constant int STEM_NONE = Xapian::QueryParser::STEM_NONE;
%constant int STEM_SOME = Xapian::QueryParser::STEM_SOME;
%constant int STEM_ALL = Xapian::QueryParser::STEM_ALL;

%typemap(in) SV ** {
	AV *tempav;
	I32 len;
	int i;
	SV  **tv;
	if (!SvROK($input))
	    croak("Argument $argnum is not a reference.");
        if (SvTYPE(SvRV($input)) != SVt_PVAV)
	    croak("Argument $argnum is not an array.");
        tempav = (AV*)SvRV($input);
	len = av_len(tempav);
	$1 = (SV **) malloc((len+2)*sizeof(SV *));
	for (i = 0; i <= len; i++) {
	    tv = av_fetch(tempav, i, 0);
	    $1[i] = *tv;
        }
	$1[i] = NULL;
};

%typemap(freearg) SV ** {
	free($1);
}

%inline %{
Xapian::Query * newN(int op_, int items, SV ** q) {
	Xapian::Query::op op = (Xapian::Query::op)op_;
	Xapian::Query * ret;

	try {
	    vector<Xapian::Query> queries;
	    queries.reserve(items);

	    for( int i = 0; i < items; i++ ) {
		SV *sv = (SV *)q[i];
		if (sv_isa(sv, "Search::Xapian::Query")) {
		    Xapian::Query *query = (Xapian::Query*) SvIV((SV*) SvRV(sv));
		    queries.push_back(*query);
		} else if ( SvOK(sv) ) {
		    STRLEN len;
		    const char * ptr = SvPV(sv, len);
		    queries.push_back(Xapian::Query(string(ptr, len)));
		} else {
		    croak( "USAGE: Search::Xapian::Query->new(OP, @TERMS_OR_QUERY_OBJECTS)" );
		}
	    }
            ret = new Xapian::Query(op, queries.begin(), queries.end());
        } catch (const Xapian::Error &error) {
            croak( "Exception: %s", error.get_msg().c_str() );
        }
	return ret;
}
%}

%extend Xapian::Enquire {
Xapian::MSet * get_mset1(int items, ...) {
	Xapian::MSet * RETVAL;
	try {
	    va_list list;
	    Xapian::Enquire * THIS;

	    Xapian::doccount first;
	    Xapian::doccount maxitems;
	    Xapian::doccount checkatleast;
	    Xapian::RSet *   rset;

	    va_start(list, items);
	    THIS = va_arg(list, Xapian::Enquire *);

	    for( int i = 1; i < items; i++ ) {
	    	 switch (i) {
		 	case 1:
			     first = va_arg(list, Xapian::doccount);
			     break;
		 	case 2:
			     maxitems = va_arg(list, Xapian::doccount);
			     break;
		 	case 3:
			     checkatleast = va_arg(list, Xapian::doccount);
			     break;
		 	case 4:
			     rset = va_arg(list, Xapian::RSet *);
			     break;
		 }
	    }

	    Xapian::MSet mset;
	    switch (items) {
		case 3:
		    mset = THIS->get_mset(first, maxitems);
		    break;
		case 4:
		    mset = THIS->get_mset(first, maxitems, checkatleast);
		    break;
		case 5:
		    mset = THIS->get_mset(first, maxitems, checkatleast, rset);
		    break;
		default:
		    croak("Bad parameter count for get_mset1");
	    }
	    RETVAL = new Xapian::MSet(mset);
	    va_end(list);
	} catch (...) {
	    Xapian::handle_exception();
	}
	return RETVAL;
}
}

%perlcode %{
package Search::Xapian;	

our $VERSION = "@PERL_XAPIAN_VERSION@";

# Items to export into caller's namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration	use Search::Xapian ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = (
                    'ops' => [ qw(
                                  OP_AND
                                  OP_OR
                                  OP_AND_NOT
                                  OP_XOR
                                  OP_AND_MAYBE
                                  OP_FILTER
                                  OP_NEAR
                                  OP_PHRASE
				  OP_VALUE_RANGE
				  OP_SCALE_WEIGHT
                                  OP_ELITE_SET
				  OP_VALUE_GE
				  OP_VALUE_LE
                                 ) ],
                    'db' => [ qw(
                                 DB_OPEN
                                 DB_CREATE
                                 DB_CREATE_OR_OPEN
                                 DB_CREATE_OR_OVERWRITE
                                 ) ],
                    'enq_order' => [ qw(
				 ENQ_DESCENDING
				 ENQ_ASCENDING
				 ENQ_DONT_CARE
				   ) ],
                    'qpflags' => [ qw(
				 FLAG_BOOLEAN
				 FLAG_PHRASE
				 FLAG_LOVEHATE
				 FLAG_BOOLEAN_ANY_CASE
				 FLAG_WILDCARD
				 FLAG_PURE_NOT
				 FLAG_PARTIAL
				 FLAG_SPELLING_CORRECTION
				 FLAG_SYNONYM
				 FLAG_AUTO_SYNONYMS
				 FLAG_AUTO_MULTIWORD_SYNONYMS
				 FLAG_DEFAULT
                                 ) ],
                    'qpstem' => [ qw(
				 STEM_NONE
				 STEM_SOME
				 STEM_ALL
                                 ) ]
                   );
$EXPORT_TAGS{standard} = [ @{ $EXPORT_TAGS{'ops'} },
			   @{ $EXPORT_TAGS{'db'} },
			   @{ $EXPORT_TAGS{'qpflags'} },
			   @{ $EXPORT_TAGS{'qpstem'} } ];
$EXPORT_TAGS{all} = [ @{ $EXPORT_TAGS{'standard'} }, @{ $EXPORT_TAGS{'enq_order'} } ];


our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

# Preloaded methods go here.

our @OP_NAMES;
foreach (@{ $EXPORT_TAGS{'ops'} }) {
  $OP_NAMES[eval $_] = $_;
}

our @DB_NAMES;
foreach (@{ $EXPORT_TAGS{'db'} }) {
  $DB_NAMES[eval $_] = $_;
}

our @FLAG_NAMES;
foreach (@{ $EXPORT_TAGS{'qpflags'} }) {
  $FLAG_NAMES[eval $_] = $_;
}

our @STEM_NAMES;
foreach (@{ $EXPORT_TAGS{'qpstem'} }) {
  $STEM_NAMES[eval $_] = $_;
}

package Search::Xapian::Database;
sub enquire {
  my $self = shift;
  my $enquire = Search::Xapian::Enquire->new( $self );
  if( @_ ) {
    $enquire->set_query( @_ );
  }
  return $enquire;
}

package Search::Xapian::Query;
sub new {
  my $class = $_[0];
  my $query;

  if( @_ == 1 ) {
    $query = new_query_new1(@_);
  } else {
    my $op = $_[1];
    if( $op !~ /^\d+$/ ) {
	Carp::croak( "USAGE: $class->new('term') or $class->new(OP, <args>)" );
    }
    if( $op == 8 ) { # FIXME: 8 is OP_VALUE_RANGE; eliminate hardcoded literal
      if( @_ != 4 ) {
	Carp::croak( "USAGE: $class->new(OP_VALUE_RANGE, VALNO, START, END)" );
      }
      $query = new_query_new4range( @_ );
    } elsif( $op == 9 ) { # FIXME: OP_SCALE_WEIGHT
      if( @_ != 3 ) {
        Carp::croak( "USAGE: $class->new(OP_SCALE_WEIGHT, QUERY, FACTOR)" );
      }
      $query = new_query_new3scale( @_ );
    } elsif( $op == 11 || $op == 12 ) { # FIXME: OP_VALUE_GE, OP_VALUE_LE; eliminate hardcoded literals
      if( @_ != 3 ) {
        Carp::croak( "USAGE: $class->new(OP_VALUE_[GL]E, VALNO, LIMIT)" );
      }
      $query = new_query_new3range( @_ );
    } else {
      my $items = @_ - 2;
      shift @_;
      shift @_;
      $query = Search::Xapian::newN( $op, $items, \@_ );
    }
  }
  return $query;
}

package Search::Xapian::Enquire;
sub set_query {
  my $self = shift;
  my $query = shift;
  if( ref( $query ) ne 'Search::Xapian::Query' ) {
    $query = Search::Xapian::Query->new( $query, @_ );
    $self->set_query1( $query );
    return;
  }
  my $nargs = scalar(@_);
  if( $nargs > 1) {
    Carp::carp( "USAGE: \$enquire->set_query(\$query) or \$enquire->set_query(\$query, \$length)" );
    exit;
  }
  if( $nargs == 0 ) {
    $self->set_query1( $query );
  } else {
    $self->set_query2( $query, shift );
  }
}

sub get_mset {
  my $self = shift;
  my $nargs = scalar(@_);
  if( $nargs == 3 ) {
    my $type = ref( $_[2] );
    if ( $type eq 'Search::Xapian::RSet' ) {
      # get_mset(first, max, rset)
      splice @_, 2, 0, (0); # insert checkatleast
    }
  }
  return $self->get_mset1( @_ );
}

%}
