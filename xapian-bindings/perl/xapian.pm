# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package xapian;
use base qw(Exporter);
use base qw(DynaLoader);
package xapianc;
bootstrap xapian;
package xapian;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package xapian;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package xapian;

*version_string = *xapianc::version_string;
*major_version = *xapianc::major_version;
*minor_version = *xapianc::minor_version;
*revision = *xapianc::revision;
*__eq__ = *xapianc::__eq__;
*__ne__ = *xapianc::__ne__;
*open_stub = *xapianc::open_stub;
*chert_open = *xapianc::chert_open;
*flint_open = *xapianc::flint_open;
*inmemory_open = *xapianc::inmemory_open;
*remote_open = *xapianc::remote_open;
*remote_open_writable = *xapianc::remote_open_writable;
*sortable_serialise = *xapianc::sortable_serialise;
*sortable_unserialise = *xapianc::sortable_unserialise;

############# Class : xapian::PositionIterator ##############

package xapian::PositionIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_PositionIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_PositionIterator($self);
        delete $OWNER{$self};
    }
}

*get_termpos = *xapianc::PositionIterator_get_termpos;
*next = *xapianc::PositionIterator_next;
*equals = *xapianc::PositionIterator_equals;
*skip_to = *xapianc::PositionIterator_skip_to;
*get_description = *xapianc::PositionIterator_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::PostingIterator ##############

package xapian::PostingIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_PostingIterator($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = xapianc::new_PostingIterator(@_);
    bless $self, $pkg if defined($self);
}

*skip_to = *xapianc::PostingIterator_skip_to;
*get_doclength = *xapianc::PostingIterator_get_doclength;
*get_wdf = *xapianc::PostingIterator_get_wdf;
*positionlist_begin = *xapianc::PostingIterator_positionlist_begin;
*positionlist_end = *xapianc::PostingIterator_positionlist_end;
*get_description = *xapianc::PostingIterator_get_description;
*get_docid = *xapianc::PostingIterator_get_docid;
*next = *xapianc::PostingIterator_next;
*equals = *xapianc::PostingIterator_equals;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::TermIterator ##############

package xapian::TermIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_TermIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_TermIterator($self);
        delete $OWNER{$self};
    }
}

*get_term = *xapianc::TermIterator_get_term;
*next = *xapianc::TermIterator_next;
*equals = *xapianc::TermIterator_equals;
*skip_to = *xapianc::TermIterator_skip_to;
*get_wdf = *xapianc::TermIterator_get_wdf;
*get_termfreq = *xapianc::TermIterator_get_termfreq;
*positionlist_begin = *xapianc::TermIterator_positionlist_begin;
*positionlist_end = *xapianc::TermIterator_positionlist_end;
*get_description = *xapianc::TermIterator_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::ValueIterator ##############

package xapian::ValueIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_ValueIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_ValueIterator($self);
        delete $OWNER{$self};
    }
}

*get_value = *xapianc::ValueIterator_get_value;
*next = *xapianc::ValueIterator_next;
*equals = *xapianc::ValueIterator_equals;
*get_valueno = *xapianc::ValueIterator_get_valueno;
*get_description = *xapianc::ValueIterator_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::Document ##############

package xapian::Document;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_Document(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_Document($self);
        delete $OWNER{$self};
    }
}

*get_value = *xapianc::Document_get_value;
*add_value = *xapianc::Document_add_value;
*remove_value = *xapianc::Document_remove_value;
*clear_values = *xapianc::Document_clear_values;
*get_data = *xapianc::Document_get_data;
*set_data = *xapianc::Document_set_data;
*add_posting = *xapianc::Document_add_posting;
*add_term = *xapianc::Document_add_term;
*remove_posting = *xapianc::Document_remove_posting;
*remove_term = *xapianc::Document_remove_term;
*clear_terms = *xapianc::Document_clear_terms;
*termlist_count = *xapianc::Document_termlist_count;
*termlist_begin = *xapianc::Document_termlist_begin;
*termlist_end = *xapianc::Document_termlist_end;
*values_count = *xapianc::Document_values_count;
*values_begin = *xapianc::Document_values_begin;
*values_end = *xapianc::Document_values_end;
*get_docid = *xapianc::Document_get_docid;
*serialise = *xapianc::Document_serialise;
*unserialise = *xapianc::Document_unserialise;
*get_description = *xapianc::Document_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::PostingSource ##############

package xapian::PostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_PostingSource($self);
        delete $OWNER{$self};
    }
}

*get_termfreq_min = *xapianc::PostingSource_get_termfreq_min;
*get_termfreq_est = *xapianc::PostingSource_get_termfreq_est;
*get_termfreq_max = *xapianc::PostingSource_get_termfreq_max;
*get_maxweight = *xapianc::PostingSource_get_maxweight;
*get_weight = *xapianc::PostingSource_get_weight;
*get_docid = *xapianc::PostingSource_get_docid;
*next = *xapianc::PostingSource_next;
*skip_to = *xapianc::PostingSource_skip_to;
*check = *xapianc::PostingSource_check;
*at_end = *xapianc::PostingSource_at_end;
*name = *xapianc::PostingSource_name;
*serialise = *xapianc::PostingSource_serialise;
*init = *xapianc::PostingSource_init;
*get_description = *xapianc::PostingSource_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::ValuePostingSource ##############

package xapian::ValuePostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::PostingSource xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_ValuePostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_termfreq_min = *xapianc::ValuePostingSource_get_termfreq_min;
*get_termfreq_est = *xapianc::ValuePostingSource_get_termfreq_est;
*get_termfreq_max = *xapianc::ValuePostingSource_get_termfreq_max;
*next = *xapianc::ValuePostingSource_next;
*skip_to = *xapianc::ValuePostingSource_skip_to;
*check = *xapianc::ValuePostingSource_check;
*at_end = *xapianc::ValuePostingSource_at_end;
*get_docid = *xapianc::ValuePostingSource_get_docid;
*init = *xapianc::ValuePostingSource_init;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_ValuePostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::ValueWeightPostingSource ##############

package xapian::ValueWeightPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::ValuePostingSource xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_ValueWeightPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_weight = *xapianc::ValueWeightPostingSource_get_weight;
*name = *xapianc::ValueWeightPostingSource_name;
*serialise = *xapianc::ValueWeightPostingSource_serialise;
*init = *xapianc::ValueWeightPostingSource_init;
*get_description = *xapianc::ValueWeightPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_ValueWeightPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::ValueMapPostingSource ##############

package xapian::ValueMapPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::ValuePostingSource xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_ValueMapPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*add_mapping = *xapianc::ValueMapPostingSource_add_mapping;
*clear_mappings = *xapianc::ValueMapPostingSource_clear_mappings;
*set_default_weight = *xapianc::ValueMapPostingSource_set_default_weight;
*get_weight = *xapianc::ValueMapPostingSource_get_weight;
*name = *xapianc::ValueMapPostingSource_name;
*serialise = *xapianc::ValueMapPostingSource_serialise;
*init = *xapianc::ValueMapPostingSource_init;
*get_description = *xapianc::ValueMapPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_ValueMapPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::FixedWeightPostingSource ##############

package xapian::FixedWeightPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::PostingSource xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_FixedWeightPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_termfreq_min = *xapianc::FixedWeightPostingSource_get_termfreq_min;
*get_termfreq_est = *xapianc::FixedWeightPostingSource_get_termfreq_est;
*get_termfreq_max = *xapianc::FixedWeightPostingSource_get_termfreq_max;
*get_weight = *xapianc::FixedWeightPostingSource_get_weight;
*next = *xapianc::FixedWeightPostingSource_next;
*skip_to = *xapianc::FixedWeightPostingSource_skip_to;
*check = *xapianc::FixedWeightPostingSource_check;
*at_end = *xapianc::FixedWeightPostingSource_at_end;
*get_docid = *xapianc::FixedWeightPostingSource_get_docid;
*name = *xapianc::FixedWeightPostingSource_name;
*serialise = *xapianc::FixedWeightPostingSource_serialise;
*init = *xapianc::FixedWeightPostingSource_init;
*get_description = *xapianc::FixedWeightPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_FixedWeightPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::MSet ##############

package xapian::MSet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_MSet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_MSet($self);
        delete $OWNER{$self};
    }
}

*fetch = *xapianc::MSet_fetch;
*convert_to_percent = *xapianc::MSet_convert_to_percent;
*get_termfreq = *xapianc::MSet_get_termfreq;
*get_termweight = *xapianc::MSet_get_termweight;
*get_firstitem = *xapianc::MSet_get_firstitem;
*get_matches_lower_bound = *xapianc::MSet_get_matches_lower_bound;
*get_matches_estimated = *xapianc::MSet_get_matches_estimated;
*get_matches_upper_bound = *xapianc::MSet_get_matches_upper_bound;
*get_uncollapsed_matches_lower_bound = *xapianc::MSet_get_uncollapsed_matches_lower_bound;
*get_uncollapsed_matches_estimated = *xapianc::MSet_get_uncollapsed_matches_estimated;
*get_uncollapsed_matches_upper_bound = *xapianc::MSet_get_uncollapsed_matches_upper_bound;
*get_max_possible = *xapianc::MSet_get_max_possible;
*get_max_attained = *xapianc::MSet_get_max_attained;
*size = *xapianc::MSet_size;
*empty = *xapianc::MSet_empty;
*begin = *xapianc::MSet_begin;
*end = *xapianc::MSet_end;
*back = *xapianc::MSet_back;
*get_hit = *xapianc::MSet_get_hit;
*get_document_percentage = *xapianc::MSet_get_document_percentage;
*get_document = *xapianc::MSet_get_document;
*get_docid = *xapianc::MSet_get_docid;
*get_description = *xapianc::MSet_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::MSetIterator ##############

package xapian::MSetIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_MSetIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_MSetIterator($self);
        delete $OWNER{$self};
    }
}

*get_docid = *xapianc::MSetIterator_get_docid;
*next = *xapianc::MSetIterator_next;
*prev = *xapianc::MSetIterator_prev;
*equals = *xapianc::MSetIterator_equals;
*get_document = *xapianc::MSetIterator_get_document;
*get_rank = *xapianc::MSetIterator_get_rank;
*get_weight = *xapianc::MSetIterator_get_weight;
*get_collapse_key = *xapianc::MSetIterator_get_collapse_key;
*get_collapse_count = *xapianc::MSetIterator_get_collapse_count;
*get_percent = *xapianc::MSetIterator_get_percent;
*get_description = *xapianc::MSetIterator_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::ESet ##############

package xapian::ESet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_ESet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_ESet($self);
        delete $OWNER{$self};
    }
}

*get_ebound = *xapianc::ESet_get_ebound;
*size = *xapianc::ESet_size;
*empty = *xapianc::ESet_empty;
*begin = *xapianc::ESet_begin;
*end = *xapianc::ESet_end;
*back = *xapianc::ESet_back;
*get_description = *xapianc::ESet_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::ESetIterator ##############

package xapian::ESetIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_ESetIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_ESetIterator($self);
        delete $OWNER{$self};
    }
}

*get_term = *xapianc::ESetIterator_get_term;
*next = *xapianc::ESetIterator_next;
*prev = *xapianc::ESetIterator_prev;
*equals = *xapianc::ESetIterator_equals;
*get_weight = *xapianc::ESetIterator_get_weight;
*get_description = *xapianc::ESetIterator_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::RSet ##############

package xapian::RSet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_RSet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_RSet($self);
        delete $OWNER{$self};
    }
}

*size = *xapianc::RSet_size;
*empty = *xapianc::RSet_empty;
*add_document = *xapianc::RSet_add_document;
*remove_document = *xapianc::RSet_remove_document;
*contains = *xapianc::RSet_contains;
*get_description = *xapianc::RSet_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::MatchDecider ##############

package xapian::MatchDecider;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *xapianc::MatchDecider___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_MatchDecider($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::Enquire ##############

package xapian::Enquire;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_Enquire(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_Enquire($self);
        delete $OWNER{$self};
    }
}

*set_query = *xapianc::Enquire_set_query;
*get_query = *xapianc::Enquire_get_query;
*set_weighting_scheme = *xapianc::Enquire_set_weighting_scheme;
*set_collapse_key = *xapianc::Enquire_set_collapse_key;
*ASCENDING = *xapianc::Enquire_ASCENDING;
*DESCENDING = *xapianc::Enquire_DESCENDING;
*DONT_CARE = *xapianc::Enquire_DONT_CARE;
*set_docid_order = *xapianc::Enquire_set_docid_order;
*set_cutoff = *xapianc::Enquire_set_cutoff;
*set_sort_by_relevance = *xapianc::Enquire_set_sort_by_relevance;
*set_sort_by_value = *xapianc::Enquire_set_sort_by_value;
*set_sort_by_value_then_relevance = *xapianc::Enquire_set_sort_by_value_then_relevance;
*set_sort_by_relevance_then_value = *xapianc::Enquire_set_sort_by_relevance_then_value;
*set_sort_by_key = *xapianc::Enquire_set_sort_by_key;
*set_sort_by_key_then_relevance = *xapianc::Enquire_set_sort_by_key_then_relevance;
*set_sort_by_relevance_then_key = *xapianc::Enquire_set_sort_by_relevance_then_key;
*INCLUDE_QUERY_TERMS = *xapianc::Enquire_INCLUDE_QUERY_TERMS;
*INCLUDE_QUERY_TERMS = *xapianc::Enquire_INCLUDE_QUERY_TERMS;
*USE_EXACT_TERMFREQ = *xapianc::Enquire_USE_EXACT_TERMFREQ;
*USE_EXACT_TERMFREQ = *xapianc::Enquire_USE_EXACT_TERMFREQ;
*get_mset = *xapianc::Enquire_get_mset;
*get_eset = *xapianc::Enquire_get_eset;
*get_matching_terms_begin = *xapianc::Enquire_get_matching_terms_begin;
*get_matching_terms_end = *xapianc::Enquire_get_matching_terms_end;
*get_description = *xapianc::Enquire_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::Weight ##############

package xapian::Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_Weight($self);
        delete $OWNER{$self};
    }
}

*name = *xapianc::Weight_name;
*serialise = *xapianc::Weight_serialise;
*unserialise = *xapianc::Weight_unserialise;
*get_sumpart = *xapianc::Weight_get_sumpart;
*get_maxpart = *xapianc::Weight_get_maxpart;
*get_sumextra = *xapianc::Weight_get_sumextra;
*get_maxextra = *xapianc::Weight_get_maxextra;
*get_sumpart_needs_doclength_ = *xapianc::Weight_get_sumpart_needs_doclength_;
*get_sumpart_needs_wdf_ = *xapianc::Weight_get_sumpart_needs_wdf_;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::BoolWeight ##############

package xapian::BoolWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::Weight xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_BoolWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *xapianc::BoolWeight_name;
*serialise = *xapianc::BoolWeight_serialise;
*unserialise = *xapianc::BoolWeight_unserialise;
*get_sumpart = *xapianc::BoolWeight_get_sumpart;
*get_maxpart = *xapianc::BoolWeight_get_maxpart;
*get_sumextra = *xapianc::BoolWeight_get_sumextra;
*get_maxextra = *xapianc::BoolWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_BoolWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::BM25Weight ##############

package xapian::BM25Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::Weight xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_BM25Weight(@_);
    bless $self, $pkg if defined($self);
}

*name = *xapianc::BM25Weight_name;
*serialise = *xapianc::BM25Weight_serialise;
*unserialise = *xapianc::BM25Weight_unserialise;
*get_sumpart = *xapianc::BM25Weight_get_sumpart;
*get_maxpart = *xapianc::BM25Weight_get_maxpart;
*get_sumextra = *xapianc::BM25Weight_get_sumextra;
*get_maxextra = *xapianc::BM25Weight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_BM25Weight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::TradWeight ##############

package xapian::TradWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::Weight xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_TradWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *xapianc::TradWeight_name;
*serialise = *xapianc::TradWeight_serialise;
*unserialise = *xapianc::TradWeight_unserialise;
*get_sumpart = *xapianc::TradWeight_get_sumpart;
*get_maxpart = *xapianc::TradWeight_get_maxpart;
*get_sumextra = *xapianc::TradWeight_get_sumextra;
*get_maxextra = *xapianc::TradWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_TradWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::Database ##############

package xapian::Database;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
*add_database = *xapianc::Database_add_database;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_Database($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = xapianc::new_Database(@_);
    bless $self, $pkg if defined($self);
}

*reopen = *xapianc::Database_reopen;
*close = *xapianc::Database_close;
*get_description = *xapianc::Database_get_description;
*postlist_begin = *xapianc::Database_postlist_begin;
*postlist_end = *xapianc::Database_postlist_end;
*termlist_begin = *xapianc::Database_termlist_begin;
*termlist_end = *xapianc::Database_termlist_end;
*positionlist_begin = *xapianc::Database_positionlist_begin;
*positionlist_end = *xapianc::Database_positionlist_end;
*allterms_begin = *xapianc::Database_allterms_begin;
*allterms_end = *xapianc::Database_allterms_end;
*get_doccount = *xapianc::Database_get_doccount;
*get_lastdocid = *xapianc::Database_get_lastdocid;
*get_avlength = *xapianc::Database_get_avlength;
*get_termfreq = *xapianc::Database_get_termfreq;
*term_exists = *xapianc::Database_term_exists;
*get_collection_freq = *xapianc::Database_get_collection_freq;
*get_value_freq = *xapianc::Database_get_value_freq;
*get_value_lower_bound = *xapianc::Database_get_value_lower_bound;
*get_value_upper_bound = *xapianc::Database_get_value_upper_bound;
*get_doclength = *xapianc::Database_get_doclength;
*keep_alive = *xapianc::Database_keep_alive;
*get_document = *xapianc::Database_get_document;
*get_spelling_suggestion = *xapianc::Database_get_spelling_suggestion;
*spellings_begin = *xapianc::Database_spellings_begin;
*spellings_end = *xapianc::Database_spellings_end;
*synonyms_begin = *xapianc::Database_synonyms_begin;
*synonyms_end = *xapianc::Database_synonyms_end;
*synonym_keys_begin = *xapianc::Database_synonym_keys_begin;
*synonym_keys_end = *xapianc::Database_synonym_keys_end;
*get_metadata = *xapianc::Database_get_metadata;
*metadata_keys_begin = *xapianc::Database_metadata_keys_begin;
*metadata_keys_end = *xapianc::Database_metadata_keys_end;
*get_uuid = *xapianc::Database_get_uuid;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::WritableDatabase ##############

package xapian::WritableDatabase;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::Database xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_WritableDatabase($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = xapianc::new_WritableDatabase(@_);
    bless $self, $pkg if defined($self);
}

*commit = *xapianc::WritableDatabase_commit;
*flush = *xapianc::WritableDatabase_flush;
*begin_transaction = *xapianc::WritableDatabase_begin_transaction;
*commit_transaction = *xapianc::WritableDatabase_commit_transaction;
*cancel_transaction = *xapianc::WritableDatabase_cancel_transaction;
*add_document = *xapianc::WritableDatabase_add_document;
*delete_document = *xapianc::WritableDatabase_delete_document;
*replace_document = *xapianc::WritableDatabase_replace_document;
*add_spelling = *xapianc::WritableDatabase_add_spelling;
*remove_spelling = *xapianc::WritableDatabase_remove_spelling;
*add_synonym = *xapianc::WritableDatabase_add_synonym;
*remove_synonym = *xapianc::WritableDatabase_remove_synonym;
*clear_synonyms = *xapianc::WritableDatabase_clear_synonyms;
*set_metadata = *xapianc::WritableDatabase_set_metadata;
*get_description = *xapianc::WritableDatabase_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::Query ##############

package xapian::Query;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
*OP_AND = *xapianc::Query_OP_AND;
*OP_OR = *xapianc::Query_OP_OR;
*OP_AND_NOT = *xapianc::Query_OP_AND_NOT;
*OP_XOR = *xapianc::Query_OP_XOR;
*OP_AND_MAYBE = *xapianc::Query_OP_AND_MAYBE;
*OP_FILTER = *xapianc::Query_OP_FILTER;
*OP_NEAR = *xapianc::Query_OP_NEAR;
*OP_PHRASE = *xapianc::Query_OP_PHRASE;
*OP_VALUE_RANGE = *xapianc::Query_OP_VALUE_RANGE;
*OP_SCALE_WEIGHT = *xapianc::Query_OP_SCALE_WEIGHT;
*OP_ELITE_SET = *xapianc::Query_OP_ELITE_SET;
*OP_VALUE_GE = *xapianc::Query_OP_VALUE_GE;
*OP_VALUE_LE = *xapianc::Query_OP_VALUE_LE;
*OP_SYNONYM = *xapianc::Query_OP_SYNONYM;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_Query($self);
        delete $OWNER{$self};
    }
}

*get_length = *xapianc::Query_get_length;
*get_terms_begin = *xapianc::Query_get_terms_begin;
*get_terms_end = *xapianc::Query_get_terms_end;
*empty = *xapianc::Query_empty;
*serialise = *xapianc::Query_serialise;
*unserialise = *xapianc::Query_unserialise;
*get_description = *xapianc::Query_get_description;
sub new {
    my $pkg = shift;
    my $self = xapianc::new_Query(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::Stopper ##############

package xapian::Stopper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *xapianc::Stopper___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_Stopper($self);
        delete $OWNER{$self};
    }
}

*get_description = *xapianc::Stopper_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::SimpleStopper ##############

package xapian::SimpleStopper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::Stopper xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_SimpleStopper(@_);
    bless $self, $pkg if defined($self);
}

*add = *xapianc::SimpleStopper_add;
*__call__ = *xapianc::SimpleStopper___call__;
*get_description = *xapianc::SimpleStopper_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_SimpleStopper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::ValueRangeProcessor ##############

package xapian::ValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_ValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

*__call__ = *xapianc::ValueRangeProcessor___call__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::StringValueRangeProcessor ##############

package xapian::StringValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::ValueRangeProcessor xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_StringValueRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *xapianc::StringValueRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_StringValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::DateValueRangeProcessor ##############

package xapian::DateValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::ValueRangeProcessor xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_DateValueRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *xapianc::DateValueRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_DateValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::NumberValueRangeProcessor ##############

package xapian::NumberValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::ValueRangeProcessor xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_NumberValueRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *xapianc::NumberValueRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_NumberValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::QueryParser ##############

package xapian::QueryParser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
*FLAG_BOOLEAN = *xapianc::QueryParser_FLAG_BOOLEAN;
*FLAG_PHRASE = *xapianc::QueryParser_FLAG_PHRASE;
*FLAG_LOVEHATE = *xapianc::QueryParser_FLAG_LOVEHATE;
*FLAG_BOOLEAN_ANY_CASE = *xapianc::QueryParser_FLAG_BOOLEAN_ANY_CASE;
*FLAG_WILDCARD = *xapianc::QueryParser_FLAG_WILDCARD;
*FLAG_PURE_NOT = *xapianc::QueryParser_FLAG_PURE_NOT;
*FLAG_PARTIAL = *xapianc::QueryParser_FLAG_PARTIAL;
*FLAG_SPELLING_CORRECTION = *xapianc::QueryParser_FLAG_SPELLING_CORRECTION;
*FLAG_SYNONYM = *xapianc::QueryParser_FLAG_SYNONYM;
*FLAG_AUTO_SYNONYMS = *xapianc::QueryParser_FLAG_AUTO_SYNONYMS;
*FLAG_AUTO_MULTIWORD_SYNONYMS = *xapianc::QueryParser_FLAG_AUTO_MULTIWORD_SYNONYMS;
*FLAG_DEFAULT = *xapianc::QueryParser_FLAG_DEFAULT;
*STEM_NONE = *xapianc::QueryParser_STEM_NONE;
*STEM_SOME = *xapianc::QueryParser_STEM_SOME;
*STEM_ALL = *xapianc::QueryParser_STEM_ALL;
sub new {
    my $pkg = shift;
    my $self = xapianc::new_QueryParser(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_QueryParser($self);
        delete $OWNER{$self};
    }
}

*set_stemmer = *xapianc::QueryParser_set_stemmer;
*set_stemming_strategy = *xapianc::QueryParser_set_stemming_strategy;
*set_stopper = *xapianc::QueryParser_set_stopper;
*set_default_op = *xapianc::QueryParser_set_default_op;
*get_default_op = *xapianc::QueryParser_get_default_op;
*set_database = *xapianc::QueryParser_set_database;
*parse_query = *xapianc::QueryParser_parse_query;
*add_prefix = *xapianc::QueryParser_add_prefix;
*add_boolean_prefix = *xapianc::QueryParser_add_boolean_prefix;
*stoplist_begin = *xapianc::QueryParser_stoplist_begin;
*stoplist_end = *xapianc::QueryParser_stoplist_end;
*unstem_begin = *xapianc::QueryParser_unstem_begin;
*unstem_end = *xapianc::QueryParser_unstem_end;
*add_valuerangeprocessor = *xapianc::QueryParser_add_valuerangeprocessor;
*get_corrected_query_string = *xapianc::QueryParser_get_corrected_query_string;
*get_description = *xapianc::QueryParser_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::Stem ##############

package xapian::Stem;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_Stem(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_Stem($self);
        delete $OWNER{$self};
    }
}

*__call__ = *xapianc::Stem___call__;
*get_description = *xapianc::Stem_get_description;
*get_available_languages = *xapianc::Stem_get_available_languages;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::TermGenerator ##############

package xapian::TermGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_TermGenerator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_TermGenerator($self);
        delete $OWNER{$self};
    }
}

*set_stemmer = *xapianc::TermGenerator_set_stemmer;
*set_stopper = *xapianc::TermGenerator_set_stopper;
*set_document = *xapianc::TermGenerator_set_document;
*get_document = *xapianc::TermGenerator_get_document;
*set_database = *xapianc::TermGenerator_set_database;
*FLAG_SPELLING = *xapianc::TermGenerator_FLAG_SPELLING;
*set_flags = *xapianc::TermGenerator_set_flags;
*index_text = *xapianc::TermGenerator_index_text;
*index_text_without_positions = *xapianc::TermGenerator_index_text_without_positions;
*increase_termpos = *xapianc::TermGenerator_increase_termpos;
*get_termpos = *xapianc::TermGenerator_get_termpos;
*set_termpos = *xapianc::TermGenerator_set_termpos;
*get_description = *xapianc::TermGenerator_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::Sorter ##############

package xapian::Sorter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *xapianc::Sorter___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_Sorter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::MultiValueSorter ##############

package xapian::MultiValueSorter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::Sorter xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_MultiValueSorter(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *xapianc::MultiValueSorter___call__;
*add = *xapianc::MultiValueSorter_add;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_MultiValueSorter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::ReplicationInfo ##############

package xapian::ReplicationInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
*swig_changeset_count_get = *xapianc::ReplicationInfo_changeset_count_get;
*swig_changeset_count_set = *xapianc::ReplicationInfo_changeset_count_set;
*swig_fullcopy_count_get = *xapianc::ReplicationInfo_fullcopy_count_get;
*swig_fullcopy_count_set = *xapianc::ReplicationInfo_fullcopy_count_set;
*swig_changed_get = *xapianc::ReplicationInfo_changed_get;
*swig_changed_set = *xapianc::ReplicationInfo_changed_set;
sub new {
    my $pkg = shift;
    my $self = xapianc::new_ReplicationInfo(@_);
    bless $self, $pkg if defined($self);
}

*clear = *xapianc::ReplicationInfo_clear;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_ReplicationInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::DatabaseMaster ##############

package xapian::DatabaseMaster;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_DatabaseMaster(@_);
    bless $self, $pkg if defined($self);
}

*write_changesets_to_fd = *xapianc::DatabaseMaster_write_changesets_to_fd;
*get_description = *xapianc::DatabaseMaster_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_DatabaseMaster($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::DatabaseReplica ##############

package xapian::DatabaseReplica;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_DatabaseReplica($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = xapianc::new_DatabaseReplica(@_);
    bless $self, $pkg if defined($self);
}

*get_revision_info = *xapianc::DatabaseReplica_get_revision_info;
*set_read_fd = *xapianc::DatabaseReplica_set_read_fd;
*apply_next_changeset = *xapianc::DatabaseReplica_apply_next_changeset;
*close = *xapianc::DatabaseReplica_close;
*get_description = *xapianc::DatabaseReplica_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::ValueSetMatchDecider ##############

package xapian::ValueSetMatchDecider;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian::MatchDecider xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_ValueSetMatchDecider(@_);
    bless $self, $pkg if defined($self);
}

*add_value = *xapianc::ValueSetMatchDecider_add_value;
*remove_value = *xapianc::ValueSetMatchDecider_remove_value;
*__call__ = *xapianc::ValueSetMatchDecider___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_ValueSetMatchDecider($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : xapian::SerialisationContext ##############

package xapian::SerialisationContext;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = xapianc::new_SerialisationContext(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        xapianc::delete_SerialisationContext($self);
        delete $OWNER{$self};
    }
}

*register_weighting_scheme = *xapianc::SerialisationContext_register_weighting_scheme;
*get_weighting_scheme = *xapianc::SerialisationContext_get_weighting_scheme;
*register_posting_source = *xapianc::SerialisationContext_register_posting_source;
*get_posting_source = *xapianc::SerialisationContext_get_posting_source;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package xapian;

*BAD_VALUENO = *xapianc::BAD_VALUENO;
*DB_CREATE_OR_OPEN = *xapianc::DB_CREATE_OR_OPEN;
*DB_CREATE = *xapianc::DB_CREATE;
*DB_CREATE_OR_OVERWRITE = *xapianc::DB_CREATE_OR_OVERWRITE;
*DB_OPEN = *xapianc::DB_OPEN;
1;
