<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>



<title>Search::Xapian - Perl XS frontend to the Xapian C++ search library.</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rev="made">
</head><body style="background-color: white;">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#export">EXPORT</a></li>
	</ul>

	<li><a href="#_db">:db</a></li>
	<li><a href="#_ops">:ops</a></li>
	<li><a href="#_qpflags">:qpflags</a></li>
	<li><a href="#_qpstem">:qpstem</a></li>
	<li><a href="#_enq_order">:enq_order</a></li>
	<li><a href="#_standard">:standard</a></li>
	<li><a href="#version_functions">Version functions</a></li>
	<li><a href="#numeric_encoding_functions">Numeric encoding functions</a></li>
	<li><a href="#todo">TODO</a></li>
	<li><a href="#credits">CREDITS</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
</ul>
<!-- INDEX END -->

<hr>
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Search::Xapian - Perl XS frontend to the Xapian C++ search library.</p>
<p>
</p>
<hr>
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>  use Search::Xapian;</pre>
<pre>  my $db = Search::Xapian::Database-&gt;new( '[DATABASE DIR]' );
  my $enq = $db-&gt;enquire( '[QUERY TERM]' );</pre>
<pre>  printf "Running query '%s'\n", $enq-&gt;get_query()-&gt;get_description();</pre>
<pre>  my @matches = $enq-&gt;matches(0, 10);</pre>
<pre>  print scalar(@matches) . " results found\n";</pre>
<pre>  foreach my $match ( @matches ) {
    my $doc = $match-&gt;get_document();
    printf "ID %d %d%% [ %s ]\n", $match-&gt;get_docid(), $match-&gt;get_percent(), $doc-&gt;get_data();
  }</pre>
<p>
</p>
<hr>
<h1><a name="description">DESCRIPTION</a></h1>
<p>This module wraps most methods of most Xapian classes. The missing classes
and methods should be added in the future. It also provides a simplified,
more 'perlish' interface to some common operations, as demonstrated above.</p>
<p>There are some gaps in the POD documentation for wrapped classes, but you
can read the Xapian C++ API documentation at
<a href="http://xapian.org/docs/apidoc/html/annotated.html">http://xapian.org/docs/apidoc/html/annotated.html</a> for details of
these.  Alternatively, take a look at the code in the examples and tests.</p>
<p>If you want to use Search::Xapian and the threads module together, make
sure you're using Search::Xapian &gt;= 1.0.4.0 and Perl &gt;= 5.8.7.  As of 1.0.4.0,
Search::Xapian uses CLONE_SKIP to make sure that the perl wrapper objects
aren't copied to new threads - without this the underlying C++ objects can get
destroyed more than once.</p>
<p>If you encounter problems, or have any comments, suggestions, patches, etc
please email the Xapian-discuss mailing list (details of which can be found at
<a href="http://xapian.org/lists">http://xapian.org/lists</a>).</p>
<p>
</p>
<h2><a name="export">EXPORT</a></h2>
<p>None by default.</p>
<p>
</p>
<hr>
<h1><a name="_db">:db</a></h1>
<dl>
<dt><strong><a name="item_db_open">DB_OPEN</a></strong>

</dt><dd>
<p>Open a database, fail if database doesn't exist.</p>
</dd>

<dt><strong><a name="item_db_create">DB_CREATE</a></strong>

</dt><dd>
<p>Create a new database, fail if database exists.</p>
</dd>

<dt><strong><a name="item_db_create_or_open">DB_CREATE_OR_OPEN</a></strong>

</dt><dd>
<p>Open an existing database, without destroying data, or create a new
database if one doesn't already exist.</p>
</dd>

<dt><strong><a name="item_db_create_or_overwrite">DB_CREATE_OR_OVERWRITE</a></strong>

</dt><dd>
<p>Overwrite database if it exists.</p>
</dd>

</dl>
<p>
</p>
<hr>
<h1><a name="_ops">:ops</a></h1>
<dl>
<dt><strong><a name="item_op_and">OP_AND</a></strong>

</dt><dd>
<p>Match if both subqueries are satisfied.</p>
</dd>

<dt><strong><a name="item_op_or">OP_OR</a></strong>

</dt><dd>
<p>Match if either subquery is satisfied.</p>
</dd>

<dt><strong><a name="item_op_and_not">OP_AND_NOT</a></strong>

</dt><dd>
<p>Match if left but not right subquery is satisfied.</p>
</dd>

<dt><strong><a name="item_op_xor">OP_XOR</a></strong>

</dt><dd>
<p>Match if left or right, but not both queries are satisfied.</p>
</dd>

<dt><strong><a name="item_op_and_maybe">OP_AND_MAYBE</a></strong>

</dt><dd>
<p>Match if left is satisfied, but use weights from both.</p>
</dd>

<dt><strong><a name="item_op_filter">OP_FILTER</a></strong>

</dt><dd>
<p>Like OP_AND, but only weight using the left query.</p>
</dd>

<dt><strong><a name="item_op_near">OP_NEAR</a></strong>

</dt><dd>
<p>Match if the words are near each other. The window should be specified, as
a parameter to <code>Search::Xapian::Query::Query</code>, but it defaults to the 
number of terms in the list.</p>
</dd>

<dt><strong><a name="item_op_phrase">OP_PHRASE</a></strong>

</dt><dd>
<p>Match as a phrase (All words in order).</p>
</dd>

<dt><strong><a name="item_op_elite_set">OP_ELITE_SET</a></strong>

</dt><dd>
<p>Select an elite set from the subqueries, and perform a query with these combined as an OR query.</p>
</dd>

<dt><strong><a name="item_op_value_range">OP_VALUE_RANGE</a></strong>

</dt><dd>
<p>Filter by a range test on a document value.</p>
</dd>

</dl>
<p>
</p>
<hr>
<h1><a name="_qpflags">:qpflags</a></h1>
<dl>
<dt><strong><a name="item_flag_default">FLAG_DEFAULT</a></strong>

</dt><dd>
<p>This gives the QueryParser default flag settings, allowing you to easily add
flags to the default ones.</p>
</dd>

<dt><strong><a name="item_flag_boolean">FLAG_BOOLEAN</a></strong>

</dt><dd>
<p>Support AND, OR, etc and bracketted subexpressions.</p>
</dd>

<dt><strong><a name="item_flag_lovehate">FLAG_LOVEHATE</a></strong>

</dt><dd>
<p>Support + and -.</p>
</dd>

<dt><strong><a name="item_flag_phrase">FLAG_PHRASE</a></strong>

</dt><dd>
<p>Support quoted phrases.</p>
</dd>

<dt><strong><a name="item_flag_boolean_any_case">FLAG_BOOLEAN_ANY_CASE</a></strong>

</dt><dd>
<p>Support AND, OR, etc even if they aren't in ALLCAPS.</p>
</dd>

<dt><strong><a name="item_flag_wildcard">FLAG_WILDCARD</a></strong>

</dt><dd>
<p>Support right truncation (e.g. Xap*).</p>
</dd>

<dt><strong><a name="item_flag_pure_not">FLAG_PURE_NOT</a></strong>

</dt><dd>
<p>Allow queries such as 'NOT apples'.</p>
</dd>
<dd>
<p>These require the use of a list of all documents in the database
which is potentially expensive, so this feature isn't enabled by
default.</p>
</dd>

<dt><strong><a name="item_flag_partial">FLAG_PARTIAL</a></strong>

</dt><dd>
<p>Enable partial matching.</p>
</dd>
<dd>
<p>Partial matching causes the parser to treat the query as a
``partially entered'' search.  This will automatically treat the
final word as a wildcarded match, unless it is followed by
whitespace, to produce more stable results from interactive
searches.</p>
</dd>

<dt><strong><a name="item_flag_spelling_correction">FLAG_SPELLING_CORRECTION</a></strong>

</dt><dt><strong><a name="item_flag_synonym">FLAG_SYNONYM</a></strong>

</dt><dt><strong><a name="item_flag_auto_synonyms">FLAG_AUTO_SYNONYMS</a></strong>

</dt><dt><strong><a name="item_flag_auto_multiword_synonyms">FLAG_AUTO_MULTIWORD_SYNONYMS</a></strong>

</dt></dl>
<p>
</p>
<hr>
<h1><a name="_qpstem">:qpstem</a></h1>
<dl>
<dt><strong><a name="item_stem_all">STEM_ALL</a></strong>

</dt><dd>
<p>Stem all terms.</p>
</dd>

<dt><strong><a name="item_stem_none">STEM_NONE</a></strong>

</dt><dd>
<p>Don't stem any terms.</p>
</dd>

<dt><strong><a name="item_stem_some">STEM_SOME</a></strong>

</dt><dd>
<p>Stem some terms, in a manner compatible with Omega (capitalised words and those
in phrases aren't stemmed).</p>
</dd>

</dl>
<p>
</p>
<hr>
<h1><a name="_enq_order">:enq_order</a></h1>
<dl>
<dt><strong><a name="item_enq_ascending">ENQ_ASCENDING</a></strong>

</dt><dd>
<p>docids sort in ascending order (default)</p>
</dd>

<dt><strong><a name="item_enq_descending">ENQ_DESCENDING</a></strong>

</dt><dd>
<p>docids sort in descending order</p>
</dd>

<dt><strong><a name="item_enq_dont_care">ENQ_DONT_CARE</a></strong>

</dt><dd>
<p>docids sort in whatever order is most efficient for the backend</p>
</dd>

</dl>
<p>
</p>
<hr>
<h1><a name="_standard">:standard</a></h1>
<p>Standard is db + ops + qpflags + qpstem</p>
<p>
</p>
<hr>
<h1><a name="version_functions">Version functions</a></h1>
<dl>
<dt><strong><a name="item_major_version">major_version</a></strong>

</dt><dd>
<p>Returns the major version of the Xapian C++ library being used.  E.g. for
Xapian 1.0.9 this would return 1.</p>
</dd>

<dt><strong><a name="item_minor_version">minor_version</a></strong>

</dt><dd>
<p>Returns the minor version of the Xapian C++ library being used.  E.g. for
Xapian 1.0.9 this would return 0.</p>
</dd>

<dt><strong><a name="item_revision">revision</a></strong>

</dt><dd>
<p>Returns the revision of the Xapian C++ library being used.  E.g. for
Xapian 1.0.9 this would return 9.  In a stable release series, Xapian libraries
with the same minor and major versions are usually ABI compatible, so this
often won't match the third component of $Search::Xapian::VERSION (which is the
version of the Search::Xapian XS wrappers).</p>
</dd>

</dl>
<p>
</p>
<hr>
<h1><a name="numeric_encoding_functions">Numeric encoding functions</a></h1>
<dl>
<dt><strong><a name="item_sortable_serialise">sortable_serialise NUMBER</a></strong>

</dt><dd>
<p>Convert a floating point number to a string, preserving sort order.</p>
</dd>
<dd>
<p>This method converts a floating point number to a string, suitable for
using as a value for numeric range restriction, or for use as a sort
key.</p>
</dd>
<dd>
<p>The conversion is platform independent.</p>
</dd>
<dd>
<p>The conversion attempts to ensure that, for any pair of values supplied
to the conversion algorithm, the result of comparing the original
values (with a numeric comparison operator) will be the same as the
result of comparing the resulting values (with a string comparison
operator).  On platforms which represent doubles with the precisions
specified by IEEE_754, this will be the case: if the representation of
doubles is more precise, it is possible that two very close doubles
will be mapped to the same string, so will compare equal.</p>
</dd>
<dd>
<p>Note also that both zero and -zero will be converted to the same
representation: since these compare equal, this satisfies the
comparison constraint, but it's worth knowing this if you wish to use
the encoding in some situation where this distinction matters.</p>
</dd>
<dd>
<p>Handling of NaN isn't (currently) guaranteed to be sensible.</p>
</dd>

<dt><strong><a name="item_sortable_unserialise_serialised_number">sortable_unserialise SERIALISED_NUMBER</a></strong>

</dt><dd>
<p>Convert a string encoded using sortable_serialise back to a floating
point number.</p>
</dd>
<dd>
<p>This expects the input to be a string produced by sortable_serialise().
If the input is not such a string, the value returned is undefined (but
no error will be thrown).</p>
</dd>
<dd>
<p>The result of the conversion will be exactly the value which was
supplied to <a href="#item_sortable_serialise"><code>sortable_serialise()</code></a> when making the string on platforms
which represent doubles with the precisions specified by IEEE_754, but
may be a different (nearby) value on other platforms.</p>
</dd>

</dl>
<p>
</p>
<hr>
<h1><a name="todo">TODO</a></h1>
<dl>
<dt><strong><a name="item_error_handling">Error Handling</a></strong>

</dt><dd>
<p>Error handling for all methods liable to generate them.</p>
</dd>

<dt><strong><a name="item_documentation">Documentation</a></strong>

</dt><dd>
<p>Add POD documentation for all classes, where possible just adapted from Xapian
docs.</p>
</dd>

<dt><strong><a name="item_unwrapped_classes">Unwrapped classes</a></strong>

</dt><dd>
<p>The following Xapian classes are not yet wrapped:
Error (and subclasses), ErrorHandler, ExpandDecider (and subclasses),
user-defined weight classes.</p>
</dd>
<dd>
<p>We don't yet wrap Xapian::Query::MatchAll, Xapian::Query::MatchNothing,
or Xapian::BAD_VALUENO.</p>
</dd>

<dt><strong><a name="item_unwrapped_methods">Unwrapped methods</a></strong>

</dt><dd>
<p>The following methods are not yet wrapped:
Enquire::get_eset(...) with more than two arguments,
Query ctor optional ``parameter'' parameter,
Remote::open(...),
static Stem::get_available_languages().</p>
</dd>
<dd>
<p>We wrap MSet::swap() and MSet::operator[](), but not ESet::swap(),
ESet::operator[]().  Is swap actually useful?  Should we instead tie MSet
and ESet to allow them to just be used as lists?</p>
</dd>

</dl>
<p>
</p>
<hr>
<h1><a name="credits">CREDITS</a></h1>
<p>Thanks to Tye McQueen &lt;<a>tye@metronet.com</a>&gt; for explaining the
finer points of how best to write XS frontends to C++ libraries, James
Aylett &lt;<a>james@tartarus.org</a>&gt; for clarifying the less obvious
aspects of the Xapian API, Tim Brody for patches wrapping ::QueryParser and
::Stopper and especially Olly Betts &lt;<a>olly@survex.com</a>&gt; for contributing
advice, bugfixes, and wrapper code for the more obscure classes.</p>
<p>
</p>
<hr>
<h1><a name="author">AUTHOR</a></h1>
<p>Alex Bowley &lt;<a>kilinrax@cpan.org</a>&gt;</p>
<p>Please report any bugs/suggestions to &lt;<a>xapian-discuss@lists.xapian.org</a>&gt;
or use the Xapian bug tracker <a href="http://xapian.org/bugs">http://xapian.org/bugs</a>.  Please do
NOT use the CPAN bug tracker or mail any of the authors individually.</p>
<p>
</p>
<hr>
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="http://xapian.org/docs/bindings/perl/Search/Xapian/BM25Weight.html">Search::Xapian::BM25Weight</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/BoolWeight.html">Search::Xapian::BoolWeight</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/Database.html">Search::Xapian::Database</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/Document.html">Search::Xapian::Document</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/Enquire.html">Search::Xapian::Enquire</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/MultiValueSorter.html">Search::Xapian::MultiValueSorter</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/PositionIterator.html">Search::Xapian::PositionIterator</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/PostingIterator.html">Search::Xapian::PostingIterator</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/QueryParser.html">Search::Xapian::QueryParser</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/Stem.html">Search::Xapian::Stem</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/TermGenerator.html">Search::Xapian::TermGenerator</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/TermIterator.html">Search::Xapian::TermIterator</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/TradWeight.html">Search::Xapian::TradWeight</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/ValueIterator.html">Search::Xapian::ValueIterator</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/Weight.html">Search::Xapian::Weight</a>,
<a href="http://xapian.org/docs/bindings/perl/Search/Xapian/WritableDatabase.html">Search::Xapian::WritableDatabase</a>,
and
<a href="http://xapian.org/">http://xapian.org/</a>.</p>

</body></html>