#!/usr/bin/perl
use strict;
use warnings;
use IO::Scalar;
use POSIX;
use autodie;

# Packs a glass database directory into a single file, e.g.:
#
# ./pack-single-file-glass-db glassdb/ packedglassdb
#
# Once you have such a database, you can just pass the filename to the
# Xapian::Database constructor instead of the usual directory path.  You can
# also open such a database from a file descriptor using a new Xapian::Database
# constructor.  So tools like quest and xapian-delve just work:
#
# xapian-delve packedglassdb

my $db_dir = shift @ARGV // die "Syntax: $0 DBDIR [OUTPUT [OFFSET]]\n";
my $output = shift @ARGV // "output";
my $embed_offset = shift @ARGV // 0;

open my $fh_out, '>', $output;

my @tables = qw(
     postlist
     docdata
     termlist
     position
     spelling
     synonym
);

sub DIR_START { 11 }
sub LEVEL_FREELIST { 254 }

if ($embed_offset > 0) {
    sysseek $fh_out, $embed_offset, SEEK_SET;
}

my (@offset, @max_blockno, @blocksize);
open my $fh_version, '<', "$db_dir/iamglass";
my $version_size = -s $fh_version;
# Allow plenty of extra space for larger root block pointers.
$version_size += 64;
my $offset = $embed_offset + $version_size;
sysseek $fh_version, 32, SEEK_SET;
read_uint($fh_version);
for my $i (0..$#tables) {
    my $root = read_uint($fh_version);
    my $val = read_uint($fh_version);
    my $num_entries = read_uint($fh_version);
    my $blocksize = read_uint($fh_version);
    my $len = read_uint($fh_version);
    if ($len > 0) {
	sysseek $fh_version, $len, SEEK_CUR;
    }

    $blocksize <<= 11;
    $blocksize[$i] = $blocksize;

    my $fh_table;
    no autodie qw(open);
    if (!open $fh_table, '<', "$db_dir/$tables[$i].glass") {
	$offset[$i] = 0;
	$max_blockno[$i] = undef;
	print "No $tables[$i] found - skipping\n";
	next;
    }

    my $filesize = -s $fh_table;
    my $max_blockno = $filesize / $blocksize;
    $max_blockno[$i] = $max_blockno;
    {
	use integer;
	$offset = ($offset + $blocksize - 1) / $blocksize;
    }
    sysseek $fh_out, $offset * $blocksize, SEEK_SET;
    while (1) {
	my $block;
	sysread $fh_table, $block, $blocksize;
	last if length($block) == 0;
	if (length($block) != $blocksize) {
	    print "Error: Short block (".length($block)."<$blocksize)\n";
	    exit(1);
	}

	# Unpack block header.
	my ($rev, $level, undef, undef, $dir_end) = unpack 'NCnnn', $block;
	# Add $offset to all block pointers in $block.
	if ($level == LEVEL_FREELIST) {
	    # FIXME: Ignore freelist blocks for now.
	} elsif ($level > 0) {
	    # Branch block.
	    my $entries = ($dir_end - DIR_START) >> 1;
	    my $template = "a".DIR_START."n$entries";
	    my @offsets = unpack $template, $block;
	    shift @offsets;
	    for my $o (@offsets) {
		#print "$o,";
		if ($o < DIR_START + 2 * $entries) {
		    print "$o too small\n";
		    next;
		}
		if ($o + 2 > length($block)) {
		    print "$o + 2 > ".length($block)."\n";
		    next;
		}
		my $size = unpack 'n', substr($block, $o, 2);
		$size &= 0x7fff;
		$o += $size - 4;
		if ($o + 4 > length($block)) {
		    print "$o + 4 > ".length($block)."\n";
		    next;
		}
		my $blockno = unpack 'N', substr($block, $o, 4);
		if ($blockno >= $max_blockno) {
		    print "Error: Block #$blockno >= $max_blockno\n";
		    exit(1);
		}
		$blockno += $offset;
		my $pack = pack 'N', $blockno;
		if (length($pack) != 4) {
		    print "packing $blockno wasn't 4 bytes but ".length($pack)."\n";
		    exit(1);
		}
		substr($block, $o, 4) = pack 'N', $blockno;
		if (length($block) != $blocksize) {
		    print "Error: Block expanded by item at offset $o\n";
		    exit(1);
		}
	    }
	}
	syswrite $fh_out, $block;
    }

    $offset[$i] = $offset;
    $offset = sysseek $fh_out, 0, SEEK_CUR;
    close $fh_table;
}

seek $fh_out, $embed_offset, SEEK_SET;

seek $fh_version, 0, SEEK_SET;
my $data;

# Copy magic, version, uuid.
sysread $fh_version, $data, 32;
syswrite $fh_out, $data;

my $rev = read_uint($fh_version);
write_uint($fh_out, $rev);

for my $i (0..$#tables) {
    my $root = read_uint($fh_version);
    my $val = read_uint($fh_version);
    my $num_entries = read_uint($fh_version);
    my $blocksize = read_uint($fh_version);
    my $len = read_uint($fh_version);
    my $freelist;
    sysread $fh_version, $freelist, $len;

    # Clear "sequential mode" flag.  If this is set, then we simply scan
    # backwards to get the previous leaf block, and rely on hitting the
    # start of the file to know when to stop (next uses $fl_first_unused, so
    # ought to work OK).
    #
    # FIXME: Profile to check if this is actually a win, and if it's enough of
    # one we could track the first block or something.
    $val &= ~0x02;

    # Adjust root block number.
    $root += $offset[$i];

    write_uint($fh_out, $root);
    write_uint($fh_out, $val);
    write_uint($fh_out, $num_entries);
    write_uint($fh_out, $blocksize);
    if ($len) {
	# Handle the freelist.
	my $fh_freelist = new IO::Scalar \$freelist;
	my $fl_rev = read_uint($fh_freelist);
	my $fl_first_unused = read_uint($fh_freelist);

	# Adjust end of freelist pointer.
	$fl_first_unused += $offset[$i];

	# Pack up replacement serialised freelist info.
	my $freelist2= '';
	my $fh_freelist2 = new IO::Scalar \$freelist2;
	write_uint($fh_freelist2, $fl_rev);
	write_uint($fh_freelist2, $fl_first_unused);
	write_uint($fh_freelist2, read_uint($fh_freelist) + $offset[$i]);
	write_uint($fh_freelist2, read_uint($fh_freelist));
	write_uint($fh_freelist2, read_uint($fh_freelist) + $offset[$i]);
	write_uint($fh_freelist2, read_uint($fh_freelist));

	write_uint($fh_out, length($freelist2));
	syswrite $fh_out, $freelist2;
    } else {
	write_uint($fh_out, $len);
    }
}
close $fh_version;

if (sysseek($fh_out, 0, SEEK_CUR) - $embed_offset > $version_size) {
    print "Error: version file too large\n";
    exit(1);
}

close $fh_out;

sub read_uint {
    my $fh = shift;
    my $v = 0;
    my $shift = 0;
    while (1) {
	my $byte;
	sysread $fh, $byte, 1;
	if (length($byte) == 0) {
	    print "EOF!\n";
	    exit(1);
	}
	$byte = ord($byte);
	$v |= ($byte & 0x7f) << $shift;
	last if ($byte & 0x80) == 0;
	$shift += 7;
    }
    return $v;
}

sub write_uint {
    my $fh = shift;
    my $v = shift;
    while (1) {
	last if ($v < 0x80);
	my $byte = chr(($v & 0x7f) | 0x80);
	syswrite $fh, $byte, 1;
	$v >>= 7;
    }
    syswrite $fh, chr($v), 1;
    return $v;
}
